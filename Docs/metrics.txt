
Число агентов в моей реализации известно заранее N = 5
Глубина графа d зависит от топологии (для цепочки 1-2-3-4-5  d=4)

Число итераций работы алгоритма равно глубине графа d
Iter_num = d

Каждый агент хранит свой id и массив длины N. В массиве агент изначально хранит свое число и постепенно накапливает числа всех агентов.
Еще агент хранит информацию о том, кто его соседи, в виде массива индексов
Суммарно агенты используют объем памяти C_m = (N + 1) * N + sum(adj_matrix)

Каждый агент вычисляет среднее арифметическое и любой из них может отправить в центр
C_center_msg = 1

Число сообщений отправленных агентом другим агентам за итерацию
C_agent_msg = C_agent_request + C_agent_response = N_Neighbours + C_agent_response <= 2 * Neighbours

Значит суммарное число сообщений, отправленных всеми агентами за итерацию <= 2 * sum(adj_matrix)

Число сложений
C_s = N - 1

Число делений
C_d = 1

